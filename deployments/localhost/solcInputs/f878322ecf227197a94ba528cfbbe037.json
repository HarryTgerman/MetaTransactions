{
  "language": "Solidity",
  "sources": {
    "contracts/Handler.sol": {
      "content": "/**\n *Submitted for verification at polygonscan.com on 2021-06-17\n */\n\n/**\n *Submitted for verification at FtmScan.com on 2021-05-26\n */\n\n// SPDX-License-Identifier: GPL-3.0\n\n/**\n *Submitted for verification at Etherscan.io on 2020-08-30\n */\n\n// File: contracts/interfaces/IERC20.sol\n\npragma solidity 0.6.12;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n// File: contracts/interfaces/IWETH.sol\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n\n// File: contracts/interfaces/IHandler.sol\n\ninterface IHandler {\n    /// @notice receive ETH\n    receive() external payable;\n\n    /**\n     * @notice Handle an order execution\n     * @param _inputToken - Address of the input token\n     * @param _outputToken - Address of the output token\n     * @param _inputAmount - uint256 of the input token amount\n     * @param _minReturn - uint256 of the min return amount of output token\n     * @param _data - Bytes of arbitrary data\n     * @return bought - Amount of output token bought\n     */\n    function handle(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        uint256 _inputAmount,\n        uint256 _minReturn,\n        bytes calldata _data\n    ) external payable returns (uint256 bought);\n\n    /**\n     * @notice Check whether can handle an order execution\n     * @param _inputToken - Address of the input token\n     * @param _outputToken - Address of the output token\n     * @param _inputAmount - uint256 of the input token amount\n     * @param _minReturn - uint256 of the min return amount of output token\n     * @param _data - Bytes of arbitrary data\n     * @return bool - Whether the execution can be handled or not\n     */\n    function canHandle(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        uint256 _inputAmount,\n        uint256 _minReturn,\n        bytes calldata _data\n    ) external view returns (bool);\n\n    function canHandleStoploss(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        uint256 _inputAmount,\n        uint256 _stoploss,\n        uint256 _slppage,\n        bytes calldata _data\n    ) external view returns (bool);\n}\n\n// File: contracts/interfaces/uniswapV2/IUniswapV2Pair.sol\n\ninterface IUniswapV2Pair {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n\n// File: contracts/libs/SafeMath.sol\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\n// File: contracts/libs/UniswapUtils.sol\n\nlibrary UniswapUtils {\n    using SafeMath for uint256;\n\n    /**\n     * @notice Returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n     * @return uint32 - block timestamp\n     */\n    function currentBlockTimestamp() internal view returns (uint32) {\n        return uint32(block.timestamp % 2**32);\n    }\n\n    /**\n     * @notice Returns sorted token addresses, used to handle return values from pairs sorted in this order\n     * @param _tokenA - Address of the token A\n     * @param _tokenB - Address of the token B\n     * @return token0 - Address of the lower token\n     * @return token1 - Address of the higher token\n     */\n    function sortTokens(address _tokenA, address _tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(\n            _tokenA != _tokenB,\n            \"UniswapUtils#sortTokens: IDENTICAL_ADDRESSES\"\n        );\n        (token0, token1) = _tokenA < _tokenB\n            ? (_tokenA, _tokenB)\n            : (_tokenB, _tokenA);\n        require(token0 != address(0), \"UniswapUtils#sortTokens: ZERO_ADDRESS\");\n    }\n\n    /**\n     * @notice Calculates the CREATE2 address for a pair without making any external calls\n     * @param _factory - Address of the uniswapV2 factory contract\n     * @param _tokenA - Address of the token A\n     * @param _tokenB - Address of the token B\n     * @param _initCodeHash - Bytes32 of the uniswap v2 pair contract unit code hash\n     * @return pair - Address of the pair\n     */\n    function pairFor(\n        address _factory,\n        address _tokenA,\n        address _tokenB,\n        bytes32 _initCodeHash\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(_tokenA, _tokenB);\n        pair = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex\"ff\",\n                        _factory,\n                        keccak256(abi.encodePacked(token0, token1)),\n                        _initCodeHash // init code hash\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @notice Calculates the CREATE2 address for a pair without making any external calls\n     * @dev Tokens should be in order\n     * @param _factory - Address of the uniswapV2 factory contract\n     * @param _token0 - Address of the token 0\n     * @param _token1 - Address of the token 1\n     * @param _initCodeHash - Bytes32 of the uniswap v2 pair contract unit code hash\n     * @return pair - Address of the pair\n     */\n    function pairForSorted(\n        address _factory,\n        address _token0,\n        address _token1,\n        bytes32 _initCodeHash\n    ) internal pure returns (address pair) {\n        pair = address(\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        hex\"ff\",\n                        _factory,\n                        keccak256(abi.encodePacked(_token0, _token1)),\n                        _initCodeHash // init code hash\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @notice Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n     * @param _amountIn - uint of the input token's amount\n     * @param _reserveIn - uint of the input token's reserve\n     * @param _reserveOut - uint of the output token's reserve\n     * @return amountOut - Maximum output amount\n     */\n    function getAmountOut(\n        uint256 _amountIn,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(\n            _amountIn > 0,\n            \"UniswapUtils#getAmountOut: INSUFFICIENT_INPUT_AMOUNT\"\n        );\n        require(\n            _reserveIn > 0 && _reserveOut > 0,\n            \"UniswapUtils#getAmountOut: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 amountInWithFee = _amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(_reserveOut);\n        uint256 denominator = _reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n}\n\n// File: contracts/libs/SafeERC20.sol\n\nlibrary SafeERC20 {\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _val\n    ) internal returns (bool) {\n        (bool success, bytes memory data) = address(_token).call(\n            abi.encodeWithSelector(_token.transfer.selector, _to, _val)\n        );\n        return success && (data.length == 0 || abi.decode(data, (bool)));\n    }\n}\n\n// File: contracts/libs/PineUtils.sol\n\nlibrary PineUtils {\n    address internal constant ETH_ADDRESS =\n        address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n\n    /**\n     * @notice Get the account's balance of token or ETH\n     * @param _token - Address of the token\n     * @param _addr - Address of the account\n     * @return uint256 - Account's balance of token or ETH\n     */\n    function balanceOf(IERC20 _token, address _addr)\n        internal\n        view\n        returns (uint256)\n    {\n        if (ETH_ADDRESS == address(_token)) {\n            return _addr.balance;\n        }\n\n        return _token.balanceOf(_addr);\n    }\n\n    /**\n     * @notice Transfer token or ETH to a destinatary\n     * @param _token - Address of the token\n     * @param _to - Address of the recipient\n     * @param _val - Uint256 of the amount to transfer\n     * @return bool - Whether the transfer was success or not\n     */\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _val\n    ) internal returns (bool) {\n        if (ETH_ADDRESS == address(_token)) {\n            (bool success, ) = _to.call{value: _val}(\"\");\n            return success;\n        }\n\n        return SafeERC20.transfer(_token, _to, _val);\n    }\n}\n\n// File: contracts/handlers/UniswapV2Handler.sol\n\n/// @notice UniswapV2 Handler used to execute an order\ncontract UniswapV2Handler is IHandler {\n    using SafeMath for uint256;\n\n    IWETH public immutable WETH;\n    address public immutable FACTORY;\n    bytes32 public immutable FACTORY_CODE_HASH;\n\n    /**\n     * @notice Creates the handler\n     * @param _factory - Address of the uniswap v2 factory contract\n     * @param _weth - Address of WETH contract\n     * @param _codeHash - Bytes32 of the uniswap v2 pair contract unit code hash\n     */\n    constructor(\n        address _factory,\n        IWETH _weth,\n        bytes32 _codeHash\n    ) public {\n        FACTORY = _factory;\n        WETH = _weth;\n        FACTORY_CODE_HASH = _codeHash;\n    }\n\n    /// @notice receive ETH\n    receive() external payable override {\n        require(\n            msg.sender != tx.origin,\n            \"UniswapV2Handler#receive: NO_SEND_ETH_PLEASE\"\n        );\n    }\n\n    /**\n     * @notice Handle an order execution\n     * @param _inputToken - Address of the input token\n     * @param _outputToken - Address of the output token\n     * @param _data - Bytes of arbitrary data\n     * @return bought - Amount of output token bought\n     */\n    function handle(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        uint256,\n        uint256,\n        bytes calldata _data\n    ) external payable override returns (uint256 bought) {\n        // Load real initial balance, don't trust provided value\n        uint256 amount = PineUtils.balanceOf(_inputToken, address(this));\n        address inputToken = address(_inputToken);\n        address outputToken = address(_outputToken);\n        address weth = address(WETH);\n\n        // Decode extra data\n        (, address relayer, uint256 fee) = abi.decode(\n            _data,\n            (address, address, uint256)\n        );\n\n        if (inputToken == weth || inputToken == PineUtils.ETH_ADDRESS) {\n            // Swap WETH -> outputToken\n            amount = amount.sub(fee);\n\n            // Convert from ETH to WETH if necessary\n            if (inputToken == PineUtils.ETH_ADDRESS) {\n                WETH.deposit{value: amount}();\n                inputToken = weth;\n            } else {\n                WETH.withdraw(fee);\n            }\n\n            // Trade\n            bought = _swap(inputToken, outputToken, amount, msg.sender);\n        } else if (\n            outputToken == weth || outputToken == PineUtils.ETH_ADDRESS\n        ) {\n            // Swap inputToken -> WETH\n            bought = _swap(inputToken, weth, amount, address(this));\n\n            // Convert from WETH to ETH if necessary\n            if (outputToken == PineUtils.ETH_ADDRESS) {\n                WETH.withdraw(bought);\n            } else {\n                WETH.withdraw(fee);\n            }\n\n            // Transfer amount to sender\n            bought = bought.sub(fee);\n            PineUtils.transfer(IERC20(outputToken), msg.sender, bought);\n        } else {\n            // Swap inputToken -> WETH -> outputToken\n            //  - inputToken -> WETH\n            bought = _swap(inputToken, weth, amount, address(this));\n\n            // Withdraw fee\n            WETH.withdraw(fee);\n\n            // - WETH -> outputToken\n            bought = _swap(weth, outputToken, bought.sub(fee), msg.sender);\n        }\n\n        // Send fee to relayer\n        (bool successRelayer, ) = relayer.call{value: fee}(\"\");\n        require(\n            successRelayer,\n            \"UniswapV2Handler#handle: TRANSFER_ETH_TO_RELAYER_FAILED\"\n        );\n    }\n\n    /**\n     * @notice Check whether can handle an order execution\n     * @param _inputToken - Address of the input token\n     * @param _outputToken - Address of the output token\n     * @param _inputAmount - uint256 of the input token amount\n     * @param _minReturn - uint256 of the min return amount of output token\n     * @param _data - Bytes of arbitrary data\n     * @return bool - Whether the execution can be handled or not\n     */\n    function canHandle(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        uint256 _inputAmount,\n        uint256 _minReturn,\n        bytes calldata _data\n    ) external view override returns (bool) {\n        address inputToken = address(_inputToken);\n        address outputToken = address(_outputToken);\n        address weth = address(WETH);\n\n        // Decode extra data\n        (, , uint256 fee) = abi.decode(_data, (address, address, uint256));\n\n        if (inputToken == weth || inputToken == PineUtils.ETH_ADDRESS) {\n            if (_inputAmount <= fee) {\n                return false;\n            }\n\n            return\n                _estimate(weth, outputToken, _inputAmount.sub(fee)) >=\n                _minReturn;\n        } else if (\n            outputToken == weth || outputToken == PineUtils.ETH_ADDRESS\n        ) {\n            uint256 bought = _estimate(inputToken, weth, _inputAmount);\n\n            if (bought <= fee) {\n                return false;\n            }\n\n            return bought.sub(fee) >= _minReturn;\n        } else {\n            uint256 bought = _estimate(inputToken, weth, _inputAmount);\n            if (bought <= fee) {\n                return false;\n            }\n\n            return _estimate(weth, outputToken, bought.sub(fee)) >= _minReturn;\n        }\n    }\n\n    function canHandleStoploss(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        uint256 _inputAmount,\n        uint256 _stoploss,\n        uint256 _slippage,\n        bytes calldata _data\n    ) external view override returns (bool) {\n        address inputToken = address(_inputToken);\n        address outputToken = address(_outputToken);\n        address weth = address(WETH);\n\n        // Decode extra data\n        (, , uint256 fee) = abi.decode(_data, (address, address, uint256));\n\n        if (inputToken == weth || inputToken == PineUtils.ETH_ADDRESS) {\n            if (_inputAmount <= fee) {\n                return false;\n            }\n            uint256 savedFunds = _estimate(\n                weth,\n                outputToken,\n                _inputAmount.sub(fee)\n            );\n            return savedFunds <= _stoploss && savedFunds >= _slippage;\n        } else if (\n            outputToken == weth || outputToken == PineUtils.ETH_ADDRESS\n        ) {\n            uint256 savedFunds = _estimate(inputToken, weth, _inputAmount);\n\n            if (savedFunds <= fee) {\n                return false;\n            }\n\n            return savedFunds.sub(fee) <= _stoploss && savedFunds >= _slippage;\n        } else {\n            uint256 savedFunds = _estimate(inputToken, weth, _inputAmount);\n            if (savedFunds <= fee) {\n                return false;\n            }\n\n            return\n                _estimate(weth, outputToken, savedFunds.sub(fee)) <=\n                _stoploss &&\n                savedFunds >= _slippage;\n        }\n    }\n\n    /**\n     * @notice Simulate an order execution\n     * @param _inputToken - Address of the input token\n     * @param _outputToken - Address of the output token\n     * @param _inputAmount - uint256 of the input token amount\n     * @param _minReturn - uint256 of the min return amount of output token\n     * @param _data - Bytes of arbitrary data\n     * @return bool - Whether the execution can be handled or not\n     * @return uint256 - Amount of output token bought\n     */\n    function simulate(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        uint256 _inputAmount,\n        uint256 _minReturn,\n        bytes calldata _data\n    ) external view returns (bool, uint256) {\n        address inputToken = address(_inputToken);\n        address outputToken = address(_outputToken);\n        address weth = address(WETH);\n\n        // Decode extra data\n        (, , uint256 fee) = abi.decode(_data, (address, address, uint256));\n\n        uint256 bought;\n\n        if (inputToken == weth || inputToken == PineUtils.ETH_ADDRESS) {\n            if (_inputAmount <= fee) {\n                return (false, 0);\n            }\n\n            bought = _estimate(weth, outputToken, _inputAmount.sub(fee));\n        } else if (\n            outputToken == weth || outputToken == PineUtils.ETH_ADDRESS\n        ) {\n            bought = _estimate(inputToken, weth, _inputAmount);\n            if (bought <= fee) {\n                return (false, 0);\n            }\n\n            bought = bought.sub(fee);\n        } else {\n            bought = _estimate(inputToken, weth, _inputAmount);\n            if (bought <= fee) {\n                return (false, 0);\n            }\n\n            bought = _estimate(weth, outputToken, bought.sub(fee));\n        }\n        return (bought >= _minReturn, bought);\n    }\n\n    /**\n     * @notice Estimate output token amount\n     * @param _inputToken - Address of the input token\n     * @param _outputToken - Address of the output token\n     * @param _inputAmount - uint256 of the input token amount\n     * @return bought - Amount of output token bought\n     */\n    function _estimate(\n        address _inputToken,\n        address _outputToken,\n        uint256 _inputAmount\n    ) internal view returns (uint256 bought) {\n        // Get uniswap trading pair\n        (address token0, address token1) = UniswapUtils.sortTokens(\n            _inputToken,\n            _outputToken\n        );\n        IUniswapV2Pair pair = IUniswapV2Pair(\n            UniswapUtils.pairForSorted(\n                FACTORY,\n                token0,\n                token1,\n                FACTORY_CODE_HASH\n            )\n        );\n\n        // Compute limit for uniswap trade\n        (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\n\n        // Optimal amounts for uniswap trade\n        uint256 reserveIn;\n        uint256 reserveOut;\n        if (_inputToken == token0) {\n            reserveIn = reserve0;\n            reserveOut = reserve1;\n        } else {\n            reserveIn = reserve1;\n            reserveOut = reserve0;\n        }\n\n        bought = UniswapUtils.getAmountOut(_inputAmount, reserveIn, reserveOut);\n    }\n\n    /**\n     * @notice Swap input token to output token\n     * @param _inputToken - Address of the input token\n     * @param _outputToken - Address of the output token\n     * @param _inputAmount - uint256 of the input token amount\n     * @param _recipient - Address of the recipient\n     * @return bought - Amount of output token bought\n     */\n    function _swap(\n        address _inputToken,\n        address _outputToken,\n        uint256 _inputAmount,\n        address _recipient\n    ) internal returns (uint256 bought) {\n        // Get uniswap trading pair\n        (address token0, address token1) = UniswapUtils.sortTokens(\n            _inputToken,\n            _outputToken\n        );\n        IUniswapV2Pair pair = IUniswapV2Pair(\n            UniswapUtils.pairForSorted(\n                FACTORY,\n                token0,\n                token1,\n                FACTORY_CODE_HASH\n            )\n        );\n\n        // Send tokens to uniswap pair\n        require(\n            SafeERC20.transfer(\n                IERC20(_inputToken),\n                address(pair),\n                _inputAmount\n            ),\n            \"UniswapV2Handler#_swap: ERROR_SENDING_TOKENS\"\n        );\n\n        // Get current reserves\n        (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\n\n        // Optimal amounts for uniswap trade\n        {\n            uint256 reserveIn;\n            uint256 reserveOut;\n            if (_inputToken == token0) {\n                reserveIn = reserve0;\n                reserveOut = reserve1;\n            } else {\n                reserveIn = reserve1;\n                reserveOut = reserve0;\n            }\n            bought = UniswapUtils.getAmountOut(\n                _inputAmount,\n                reserveIn,\n                reserveOut\n            );\n        }\n\n        // Determine if output amount is token1 or token0\n        uint256 amount1Out;\n        uint256 amount0Out;\n        if (_inputToken == token0) {\n            amount1Out = bought;\n        } else {\n            amount0Out = bought;\n        }\n\n        // Execute swap\n        pair.swap(amount0Out, amount1Out, _recipient, bytes(\"\"));\n    }\n}\n"
    },
    "contracts/Stoploss.sol": {
      "content": "//\n// Original work by Pine.Finance\n//  - https://github.com/pine-finance\n//\n// Authors:\n//  - Ignacio Mazzara <@nachomazzara>\n//  - Agustin Aguilar <@agusx1211>\n\n//\n//\n//                                                /\n//                                                @,\n//                                               /&&\n//                                              &&%%&/\n//                                            &%%%%&%%,..\n//                                         */%&,*&&&&&&%%&*\n//                                           /&%%%%%%%#.\n//                                    ./%&%%%&#/%%%%&#&%%%&#(*.\n//                                         .%%%%%%%&&%&/ ..,...\n//                                       .*,%%%%%%%%%&&%%%%(\n//                                     ,&&%%%&&*%%%%%%%%.*(#%&/\n//                                  ./,(*,*,#%%%%%%%%%%%%%%%(,\n//                                 ,(%%%%%%%%%%%%&%%%%%%%%%#&&%%%#/(*\n//                                     *#%%%%%%%&%%%&%%#%%%%%%(\n//                              .(####%%&%&#*&%%##%%%%%%%%%%%#.,,\n//                                      ,&%%%%%###%%%%%%%%%%%%#&&.\n//                             ..,(&%%%%%%%%%%%%%%%%%%&&%%%%#%&&%&%%%%&&#,\n//                           ,##//%((#*/#%%%%%%%%%%%%%%%%%%%%%&(.\n//                                  (%%%%%%%%%%%%%%%%%%%#%%%%%%%%%&&&&#(*,\n//                                   ./%%%%&%%%%#%&%%%%%%##%%&&&&%%(*,\n//                                #%%%%%%&&%%%#%%%%%%%%%%%%%%%&#,*&&#.\n//                            /%##%(%&/ #%%%%%%%%%%%%%%%%%%%%%%%%%&%%%.\n//                                 *&%%%%&%%%%%%%%#%%%%%%%%%%%%%%%%%&%%%#%#%%,\n//                        .*(#&%%%%%%%%&&%%%%%%%%%%#%%%%%%%%%%%%%%%(,\n//                    ./#%%%%%%%%%%%%%%%%%%%%%%%#%&%#%%%%%%%%%%%%%%%%%%%%&%%%#####(.\n//                          .,,*#%%%%%%%%%%%%%##%%&&%#%%%%%%%%&&%%%%%%(&*#&**/(*\n//                        .,(&%%%%%#((%%%%%%#%%%%%%%%%#%%%%%%%&&&&&%%%%&%*\n//                         ,,,,,..*&%%%%%%%%%%%%%%%%%%%%%%%&%%%%%%%%%#/*.\n//                           ,#&%%%%%%%%%%%%%%%%%%%%%%%%&%%%%%%%%%%%%%%%%%%/,\n//           .     .,*(#%%%%%%%%%&&&&%%%%%%&&&%%%%%%%%%&&%##%%%%%#,(%%%%%%%%%%%(((*\n//             ,/((%%%%%#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#%%%%%%%&#  . . ...\n//                      .,.,,**(%%%%%%%%&%##%%%%%%%%%%%%%%%%%%###%%%%%%%%%&*\n//                       ,%&%%%%%&&%%%%%%%#%%%%%%%%%%%%%%%%%%&%%%%##%%%%%%%%%%%%%%%%&&#.\n//              .(&&&%%%%%%&#&&%&%%%%%%%##%%%%&&%%%#%%%%%%&%%%%%%&&%%%%&&&/*(,(#(,,.\n//                         ..&%%%%%%#%#%%%%%%%%%%%##%%%%%%%&%%%%%%%%%%%%%%%%&&(.\n//                      ,%%%%%%%%%##%%%&%%%%%%%%&%%#%%&&%%%%&%%%%%%&%%%%%&(#%%%#,\n//              ./%&%%%%%%%%%%%%%%%%%%%%%%%%%&&&%%%##%%%%%%%%%%%%%&&&%%%%%%%%&#.//*/,..\n//      ,#%%%%%%%%%%%%%%%%%%&&%%%%%&&&&%%%%%&&&%%%%%#%%%%#%%%%%%%%%%%%%%%%%%%%%%%%%%&&(,..\n//            ,#* ,&&&%,.,*(%%%%%%%%%&%%%%&&&%%%%%&%%%%#%%%%##%%%%%%%&&%%%%%%%%%%%#%%%%%%%%&%(*.\n//          .,,/((#%&%#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%&&&&&%#%%%%%%%%%%%%%%%%%#%%%%%%%((*\n// *,//**,...,/#%%%%%%%%%%%&&&&%%%%%%%%%%%%%#%%%%%%&&&%%%%&&&&%%%#%%#%%%%%%%%%%%%%%%#*.       .,(#%&@*\n//  .*%%(*(%%%%%%%%%%&&&&&&&&%%%%%%%&&%%%%%%%%%%%%%&&&%%%%%%%%%##%%%%%%%%%%%%%%%%%%%%%%%%%%%&%%%/..\n//      .,/%&%%%%%%@#(&%&%%%%%%%%%#&&%%##%#%%%#%%%%&&&%%%%%%%%###%%%%%&&&%%%%%%%%%%%%%%%%&(//%%/\n//          ,..     .(%%%%##%%%#%%%%%%#%%%%%##%%%%%&&&&%%%%%%%#&%#%%%%%%&&&%%%%%##//  ,,.\n//            .,(%#%%##%%%#%%%#%%%#%%*,.*%%%%%%%%%&.,/&%%%%%%% #&%%#%%%%%&%(&%((%&&&(*\n//                        ,/#/(%%,    ,&%%#%/.//         %*&(%#    .(,(%%%.\n\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./libs/PineUtils.sol\";\nimport \"./libs/SafeERC20.sol\";\nimport \"./libs/SafeMath.sol\";\nimport \"./Interfaces/IModule.sol\";\nimport \"./Interfaces/IHandler.sol\";\nimport \"./Interfaces/IERC20.sol\";\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see {ERC20Detailed}.\n */\n\n// File: contracts/interfaces/IModule.sol\n\n// File: contracts/interfaces/IHandler.sol\n\n// File: contracts/commons/Order.sol\n\ncontract Order {\n    address public constant ETH_ADDRESS =\n        address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\n\n// File: contracts/modules/LimitOrders.sol\n\n/*\n * Original work by Pine.Finance\n * - https://github.com/pine-finance\n *\n * Authors:\n * - Agustin Aguilar <agusx1211>\n * - Ignacio Mazzara <nachomazzara>\n */\ncontract Stoploss is IModule, Order {\n    using SafeMath for uint256;\n\n    /// @notice receive ETH\n    receive() external payable override {}\n\n    /**\n     * @notice Executes an order\n     * @param _inputToken - Address of the input token\n     * @param _owner - Address of the order's owner\n     * @param _data - Bytes of the order's data\n     * @param _auxData - Bytes of the auxiliar data used for the handlers to execute the order\n     * @return protectedFunds - amount of output token in saved value\n     */\n    function execute(\n        IERC20 _inputToken,\n        uint256,\n        address payable _owner,\n        bytes calldata _data,\n        bytes calldata _auxData\n    ) external override returns (uint256 protectedFunds) {\n        (IERC20 outputToken, uint256 _stoploss, uint256 _slippage) = abi.decode(\n            _data,\n            (IERC20, uint256, uint256)\n        );\n\n        IHandler handler = abi.decode(_auxData, (IHandler));\n\n        // Do not trust on _inputToken, it can mismatch the real balance\n        uint256 inputAmount = PineUtils.balanceOf(_inputToken, address(this));\n        // Handler gets Input Tokens\n        _transferAmount(_inputToken, address(handler), inputAmount);\n\n        handler.handle(\n            _inputToken,\n            outputToken,\n            inputAmount,\n            _stoploss,\n            _auxData\n        );\n\n        protectedFunds = PineUtils.balanceOf(outputToken, address(this));\n        require(\n            protectedFunds <= _stoploss,\n            \"StopLossOrders#execute: STOPLOSS_THRESHOLD_NOT_REACHED\"\n        );\n        require(\n            protectedFunds >= _slippage,\n            \"StopLossOrders#execute: OUTSIDE_SLIPPAGE\"\n        );\n\n        _transferAmount(outputToken, _owner, protectedFunds);\n\n        return protectedFunds;\n    }\n\n    /**\n     * @notice Check whether an order can be executed or not\n     * @param _inputToken - Address of the input token\n     * @param _inputAmount - uint256 of the input token amount (order amount)\n     * @param _data - Bytes of the order's data\n     * @param _auxData - Bytes of the auxiliar data used for the handlers to execute the order\n     * @return bool - whether the order can be executed or not\n     */\n    function canExecute(\n        IERC20 _inputToken,\n        uint256 _inputAmount,\n        bytes calldata _data,\n        bytes calldata _auxData\n    ) external view override returns (bool) {\n        (IERC20 outputToken, uint256 _stoploss, uint256 _slippage) = abi.decode(\n            _data,\n            (IERC20, uint256, uint256)\n        );\n        IHandler handler = abi.decode(_auxData, (IHandler));\n\n        return\n            handler.canHandleStoploss(\n                _inputToken,\n                outputToken,\n                _inputAmount,\n                _stoploss,\n                _slippage,\n                _auxData\n            );\n    }\n\n    /**\n     * @notice Transfer token or Ether amount to a recipient\n     * @param _token - Address of the token\n     * @param _to - Address of the recipient\n     * @param _amount - uint256 of the amount to be transferred\n     */\n    function _transferAmount(\n        IERC20 _token,\n        address payable _to,\n        uint256 _amount\n    ) internal {\n        if (address(_token) == ETH_ADDRESS) {\n            (bool success, ) = _to.call{value: _amount}(\"\");\n            require(\n                success,\n                \"LimitOrders#_transferAmount: ETH_TRANSFER_FAILED\"\n            );\n        } else {\n            require(\n                SafeERC20.transfer(_token, _to, _amount),\n                \"LimitOrders#_transferAmount: TOKEN_TRANSFER_FAILED\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/libs/PineUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"../Interfaces/IERC20.sol\";\nimport \"./SafeERC20.sol\";\n\nlibrary PineUtils {\n    address internal constant ETH_ADDRESS =\n        address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\n\n    /**\n     * @notice Get the account's balance of token or ETH\n     * @param _token - Address of the token\n     * @param _addr - Address of the account\n     * @return uint256 - Account's balance of token or ETH\n     */\n    function balanceOf(IERC20 _token, address _addr)\n        internal\n        view\n        returns (uint256)\n    {\n        if (ETH_ADDRESS == address(_token)) {\n            return _addr.balance;\n        }\n\n        return _token.balanceOf(_addr);\n    }\n\n    /**\n     * @notice Transfer token or ETH to a destinatary\n     * @param _token - Address of the token\n     * @param _to - Address of the recipient\n     * @param _val - Uint256 of the amount to transfer\n     * @return bool - Whether the transfer was success or not\n     */\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _val\n    ) internal returns (bool) {\n        if (ETH_ADDRESS == address(_token)) {\n            (bool success, ) = _to.call{value: _val}(\"\");\n            return success;\n        }\n\n        return SafeERC20.transfer(_token, _to, _val);\n    }\n}\n"
    },
    "contracts/libs/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.6.12;\n\nimport \"../Interfaces/IERC20.sol\";\n\nlibrary SafeERC20 {\n    function transfer(\n        IERC20 _token,\n        address _to,\n        uint256 _val\n    ) internal returns (bool) {\n        (bool success, bytes memory data) = address(_token).call(\n            abi.encodeWithSelector(_token.transfer.selector, _to, _val)\n        );\n        return success && (data.length == 0 || abi.decode(data, (bool)));\n    }\n}\n"
    },
    "contracts/libs/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/Interfaces/IModule.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IERC20.sol\";\n\ninterface IModule {\n    /// @notice receive ETH\n    receive() external payable;\n\n    /**\n     * @notice Executes an order\n     * @param _inputToken - Address of the input token\n     * @param _inputAmount - uint256 of the input token amount (order amount)\n     * @param _owner - Address of the order's owner\n     * @param _data - Bytes of the order's data\n     * @param _auxData - Bytes of the auxiliar data used for the handlers to execute the order\n     * @return bought - amount of output token bought\n     */\n    function execute(\n        IERC20 _inputToken,\n        uint256 _inputAmount,\n        address payable _owner,\n        bytes calldata _data,\n        bytes calldata _auxData\n    ) external returns (uint256 bought);\n\n    /**\n     * @notice Check whether an order can be executed or not\n     * @param _inputToken - Address of the input token\n     * @param _inputAmount - uint256 of the input token amount (order amount)\n     * @param _data - Bytes of the order's data\n     * @param _auxData - Bytes of the auxiliar data used for the handlers to execute the order\n     * @return bool - whether the order can be executed or not\n     */\n    function canExecute(\n        IERC20 _inputToken,\n        uint256 _inputAmount,\n        bytes calldata _data,\n        bytes calldata _auxData\n    ) external view returns (bool);\n}\n"
    },
    "contracts/Interfaces/IHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\nimport \"./IERC20.sol\";\n\ninterface IHandler {\n    /// @notice receive ETH\n    receive() external payable;\n\n    /**\n     * @notice Handle an order execution\n     * @param _inputToken - Address of the input token\n     * @param _outputToken - Address of the output token\n     * @param _inputAmount - uint256 of the input token amount\n     * @param _minReturn - uint256 of the min return amount of output token\n     * @param _data - Bytes of arbitrary data\n     * @return bought - Amount of output token bought\n     */\n    function handle(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        uint256 _inputAmount,\n        uint256 _minReturn,\n        bytes calldata _data\n    ) external payable returns (uint256 bought);\n\n    /**\n     * @notice Check whether can handle an order execution\n     * @param _inputToken - Address of the input token\n     * @param _outputToken - Address of the output token\n     * @param _inputAmount - uint256 of the input token amount\n     * @param _minReturn - uint256 of the min return amount of output token\n     * @param _data - Bytes of arbitrary data\n     * @return bool - Whether the execution can be handled or not\n     */\n    function canHandle(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        uint256 _inputAmount,\n        uint256 _minReturn,\n        bytes calldata _data\n    ) external view returns (bool);\n\n    function canHandleStoploss(\n        IERC20 _inputToken,\n        IERC20 _outputToken,\n        uint256 _inputAmount,\n        uint256 _stoploss,\n        uint256 _slppage,\n        bytes calldata _data\n    ) external view returns (bool);\n}\n"
    },
    "contracts/Interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.12;\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}